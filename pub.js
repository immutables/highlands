'use strict'

const ops = require('./ops')
const buck = require('./buck')
const mods = require('./mods')
const libs = require('./libs')

const env = {
  username: 'PUBLISH_USERNAME',
  password: 'PUBLISH_PASSWORD',
  repository: 'PUBLISH_REPOSITORY',
}

const outDir = '.out'
const localRepo = `file://${outDir}`
const repository = (process.env[env.repository] || '').replace(/\/$/, '')
const kvSamePlaceholder = '<&>'
const javaRules = {java_library: true, kotlin_library: true}
const stringsArrayKeys = {exclude:true, content:true}

const stagedObjects = []
let publishTargets, conf, artifacts

class PublishTarget {

  get versionSuffix() {
    let v = version()
    return v ? '-' + v : ''
  }

  get file() {
    // putting it under repositoryPath in outDir doesn't work with zip for some reason
    return `${outDir}/${this.filename}`
  }

  get filename() {
    throw Error("Subclass should override this property")
  }

  get repoDir() {
    throw Error("Subclass should override this property")
  }

  prepare() {}

  get repositoryPath() {
    return `${repositoryPath()}/${this.repoDir}/${version()}`
  }

  push() {
    upload(this.file, `${this.repositoryPath}/${this.filename}`)
  }
}

class FatJar extends PublishTarget {

  constructor(pattern, options) {
    super()
    this.target = buck.target(pattern)
    this.options = options
  }

  get filename() {
    return `${this.target.basename}-${this.target.goal}${this.versionSuffix}.jar`
  }

  get repoDir() {
    return `${this.target.basename}-${this.target.goal}`
  }

  prepare() {
    const [{[buck.attr.outputPath]: outFile}] = buck.info(this.target)
    ops.copy(outFile, this.file)
  }
}

class Zip extends PublishTarget {

  constructor(dir, options) {
    super()
    this.dir = dir
    this.options = options
  }

  get filename() {
    return `${this.dir}${this.versionSuffix}.zip`
  }

  get repoDir() {
    return this.dir
  }

  prepare() {
    let content = [].concat(this.options.content || this.dir).join(' ')
    let exclude = [].concat(this.options.exclude || []).map(x => `-not -name '${x}'`).join(' ')

    ops.unlink(this.file)

    ops.exec(`cd ${content} && find . -type f ${exclude} -exec zip ../${this.file} {} +`)
  }

  toString() {
    let opts = options(this.options)
        .replace(/\n/g, ' ')
        .replace(/,\s+([\}\]])/g, '$1')
        .replace(/\s+/g, ' ')
        .trim()

    return `${this.dir}.zip${opts})`
  }
}

function version() {
  return conf['maven.publish_ver']
}

function repositoryPath() {
  return conf['maven.publish_group'].replace(/\./g, '/')
}

function zip(dir, options = {}) {
  stagedObjects.push(new Zip(trimSlashes(dir), options))
}

function fatJar(target, options = {}) {
  stagedObjects.push(new FatJar(target, options))
}

function upload(file, repositoryFilename) {
  if (!repository) return

  let sha1 = ops.exec(`shasum -a 1 ${file} | awk '{ print $1 }'`).trim()

  ops.exec(`curl --fail \
--connect-timeout ${ops.use.timeout} \
-u $${env.username}:$${env.password} \
-H "X-Checksum-Sha1:${sha1}" \
-X PUT "${repository}/${repositoryFilename}" \
-T "${file}"`)
}

function exportLibraries() {
  let defs = libs.all.map(a => `
    .lib('${a.target}', ${strings(a.jars)}${options(a.options)})`)

  let content = `// Generated by 'node up --publish'
module.exports = function(define, options) {
  const {repo} = options || {}
  define${defs.join('')}
}
`
  ops.write(`${outDir}/thirdparty-${version()}.js`, content)
}

function exportModules() {
  let defs = artifacts.map(a => `
    .lib('${targetOf(a)}', ${strings(jarOf(a))}${options(optionsOf(a))})`)

  let content = `// Generated by 'node up --publish'
module.exports = function(define, options) {
  const {repo} = options || {}
  define${defs.join('')}
}
`
  ops.write(`${outDir}/artifacts-${version()}.js`, content)
}

function uploadJs() {
  let v = version(),
      p = repositoryPath()
  upload(
      `${outDir}/thirdparty-${v}.js`,
      `${p}/thirdparty/${v}/thirdparty-${v}.js`)
  upload(
      `${outDir}/artifacts-${v}.js`,
      `${p}/artifacts/${v}/artifacts-${v}.js`)
}

function optionsOf(a) {
  // not sure this is best or correct set of dependencies
  // probably should work without first_order_deps()
  let target = targetOf(a)
  let deps = buck.query(`deps('${target}', 1, first_order_deps())`)
  let selfIndex = deps.indexOf(target)
  if (selfIndex !== -1) {
    deps.splice(selfIndex, 1)
  }
  let result = {srcs: []}
  if (deps.length) {
    result['deps'] = deps.filter(d => !isAnnotationProcessor(d))
    result['repo'] = kvSamePlaceholder
  }
  return result
}

function targetOf(a) { return a[buck.attr.qname] }

function jarOf(a) { return a[buck.attr.mavenCoords] }

function ruleOf(a) { return a[buck.attr.type] }

function quote(a) { return `'${a}'` }

function isAnnotationProcessor(p) {
  return !!processorClassOf(p)
}

function processorClassOf(p) {
  let definition = libs.byTarget[p]
  return definition && definition.options && definition.options.processor
}

function options(o) {
  let ks = Object.keys(o)
  if (!ks.length) return ''
  let attrs = []
  for (let k of ks) {
    let v = k in stringsArrayKeys ? strings(o[k], '  ') : JSON.stringify(o[k])
    if (v == `"${kvSamePlaceholder}"`) attrs.push(`
      ${k},`)
    else attrs.push(`
      ${k}: ${v},`)
  }
  return `, {${attrs.join('')}
    }`
}

function strings(strings, indent) {
  strings = [].concat(strings)
  if (strings.length < 2) return quote(strings[0])
  let elements = strings.map(s => `
      ${indent || ''}${quote(s)},`)
  return `[${elements.join('')}
    ${indent || ''}]`
}

function prepare() {
  if (publishTargets) return // noop if already consumed stagedObjects

  publishTargets = stagedObjects
  conf = JSON.parse(ops.exec(`buck audit config maven --json`))
  // Only jars we want to publish will end up here
  // we will not pickup generated libraries here as they have
  // maven_coords on a prebuilt_jar rule, not on a corresponding java_library
  artifacts = buck.info(`//...`)
      .filter(t => ruleOf(t) in javaRules && jarOf(t))
}

function trimSlashes(path) {
  return path.replace(/^[/]+/, '').replace(/[/]+$/, '')
}

function publishArtifacts() {
  // store it in local repo for inspection in case of failure
  for (let t of artifacts) {
    ops.lesser(ops.exec(`buck publish ${targetOf(t)} \
--remote-repo ${localRepo}`))
  }
  if (!repository) return
  for (let t of artifacts) {
    ops.lesser(ops.exec(`buck publish ${targetOf(t)} \
--username $${env.username} \
--password $${env.password} \
--remote-repo $${env.repository}`))
  }
}

function publish() {
  ops.mkdirs(outDir)

  exportLibraries()
  exportModules()

  if (!repository) {
    // same check is performed for each artifact/archive to noop sending files
    // after those generated, but we warn/info it just once
    ops.err(`${env.repository} env variable is not set, skipping publishing to remote repository`)
  }

  // console.log(ops.exec(`echo "${env.username}=$${env.username} ${env.password}=$${env.password} ${env.repository}=$${env.repository}"`))
  uploadJs()

  publishTargets.forEach(d => d.prepare())
  publishArtifacts()
  publishTargets.forEach(d => d.push())
}

module.exports = {
  prepare, zip, fatJar, publish,

  toString() {
    return [
        'Artifacts',
        ...artifacts.map(t => '\t' + targetOf(t) + ' [' + jarOf(t) + ']'),
        'Archives',
        ...publishTargets.map(d => '\t' + d)
    ].join('\n')
  }
}
