'use strict'
const paths = require('path')
const buck = require('./buck')
const ops = require('./ops')
const mvn = require('./mvn')
const lock = require('./lock')

// TODO establish a way to declare non-exported dependencies for libraries
// currently each such library have jars as exported dependencies, need implement
// configuration syntax to mark some jars non-exported and make sure this works in IDE

const GEN_BANNER = '# Generated by up.js --lib, do not edit, manual edits will be overridden'

class Lib {
  constructor(target, jars, srcs, options) {
    Object.assign(this, {
      target,
      jars,
      srcs,
      options,
    })
  }

  get path() {
    return this.target.path
  }

  get name() {
    return `//${this.target.abbr}`
  }

  get flatname() {
    return this.name.replace(/[-.:/]/g, '_')
  }

  symlinkJar(jar) {
    return paths.join(this.path, '.out', `${jar.filenameJar}`)
  }

  symlinkSrc(jar) {
    return paths.join(this.path, '.out', `${jar.filenameSrc}`)
  }

  toBuckRules() {
    return buck.rules(this.target, this.jars, this.srcs, this.options)
  }

  toString() {
    return `${this.name} [${this.jars.join(' ')}]`
  }
}

Lib.fromRaw = function(target, jars, options) {
  if (!options && jars.constructor == Object) {
    // shortened syntax when no maven jars, only options
    options = jars
    jars = []
  }
  options = options || {}
  target = buck.target(target)

  if (options.internal) {
    let filenameJar = options.jar || (target.goal + '.jar'),
        filenameSrc = options.src || (target.goal + '.src.jar')
    let asJars = [{
      filenameJar,
      filenameSrc,
      toString() { return `internal: ${filenameJar}, ${filenameSrc}` }
    }]
    return new Lib(target, asJars, asJars, options)
  }

  let toCoords = j => mvn.coords(j, options)
  jars = [].concat(jars).map(toCoords)
  let srcs = options.srcs && [].concat(options.srcs).map(toCoords)

  if (srcs
      && srcs.length > 0
      && srcs.length !== jars.length) {
    throw `Library ${target}, 'options.srcs' are not matching number or jars`
  }

  return new Lib(target, jars, srcs || jars, options)
}

module.exports = {
  includes: [],
  staged: [],
  all: [],
  byTarget: {},
  byPath: {},

  toString() {
    return ['Libraries', ...this.all].map(String).join('\n\t')
  },

  include(loader, options) {
    // loader should be parameterless callback to
    // call require from the context of the caller
    // or anything which supplies function that called
    // and it replays .lib directives
    // loader: ()=>(libs, options)=>void
    // where
    // libs: {lib: ()=>Self}
    // options: {repo}
    this.includes.push({loader, options})
  },

  prepare() {
    if (this.all.length) return

    lock.load()
        .map(([...args]) => Lib.fromRaw(...args))
        .forEach(l => this.add(l))
  },

  uplock() {
    if (this.all.length) {
      ops.err('intenal problem: libraries already defined')
      return
    }
    if (lock.exists()) {
      // Load from lockfile to cache known checksums,
      // however we are not applying libraries from lockfile
      // by discarding the result
      lock.load()
    }
    // here we process delayed includes, because those includes may
    // not be available yet as files when commands like `up --grab`
    // is executed to actually download these
    // please take a note, that we only allow `.lib()` directives in included
    // library scripts, not the full set directives on `up` object
    // we do look at includes when regenerating libraries/lock file
    // and ignore those includes when just redoing libraries from lock etc
    for (let {loader, options} of this.includes) {
      let self = this
      loader()({
        lib(...args) {
          self.stage(...args)
          return this
        }
      }, options)
    }
    this.includes = []

    this.staged.forEach(l => this.add(l))
    lock.store(this.staged)
  },

  stage(...args) {
    this.staged.push(Lib.fromRaw(...args))
  },

  add(lib) {
    this.all.push(lib)
    this.addByTarget(lib)
    this.addByPath(lib)
  },

  addByTarget(lib) {
    let k = String(lib.target)
    if (k in this.byTarget) throw `Duplicate library ${k}`
    this.byTarget[k] = lib
  },

  addByPath(lib) {
    let d = this.byPath
    ;(d[lib.path] || (d[lib.path] = [])).push(lib)
  },

  genBuckfiles() {
    for (let [path, ls] of Object.entries(this.byPath)) {
      if (ls.some(l => l.options.internal)) {
        if (ls.some(l => !l.options.internal)) {
          throw `Don't mix internal libraries with 3rd-party on a same path ${path}`
        }
        // don't write internal libraries they already exist, we only need
        // to make sure they are properly propagated in IDE libraries
      } else {
        ops.write(
            paths.join(path, 'BUCK'),
            [GEN_BANNER, ...ls.flatMap(l => l.toBuckRules())].join(''))
      }
    }
    // we've written some BUCK files so make sure we
    // will re-query buck
    buck.dropCache()
  },
}
